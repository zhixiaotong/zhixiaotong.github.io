{"pages":[{"title":"","text":"简介喜欢折腾的JAVA程序猿、JS爱好者 平时里喜欢听歌，各种各样的歌 杰伦是我偶像联系我QQ：947803089 Email：zhixiaotong.me@qq.com Github：https://github.com/zhixiaotong","link":"/about/index.html"},{"title":"","text":"","link":"/music/index.html"}],"posts":[{"title":"记录一下","text":"撒花~属于我的博客小窝搭建完成！！！今后会在此记录工作实践中遇到的问题和对学习知识内容的理解！多多指教！","link":"/2019/07/31/record/"},{"title":"使用gzip优化页面加载遇到的问题","text":"背景我司目前项目已经经过了很多次优化了，期间通过webpack打包实践了很多种方式，包括样式文件通过gulp实现命令行级别输出到static目录下，避免了此类css的打包，通过equire插件实现了echarts的按需引入，换掉了momentjs替换成了轻量的dayjs，还有一些比较细的优化，在此就不一一列举了。 但是由于多页面配置，每个页面的js都挺大的，导致进入页面不是很流畅。期间曾经尝试了gzip，栽坑里了，由于需求原因又搁置了，近期手头工作比较少，又开始了踩坑的路途。 为什么使用gzip？gzip是一种通用的压缩算法，可以降低网络传输的数据量，从而提高客户端浏览器的访问速度。由于浏览器向服务器发送请求，加载服务器响应的静态资源，当资源文件过大，会导致用户感受的加载时间较长，影响用户体验。 虽然浏览器还需要解压gzip文件，但这速度跟加载一个未压缩的文件相比，简直少得不要不要的了。 当然，我们可以通过采用其他优化方式并用提高页面加载速度，实在无济于事了，也可以加一朵旋转的小菊花[狗头]，但gzip的使用能大幅降低加载时间，何乐而不为呢？ 在打包代码时使用gzip由于项目是基于vue开发，在vue.config.js中添加下列配置即可。（react也大同小异） 12345678910const CompressionPlugin = require('compression-webpack-plugin')...module.exports = { ... chainWebpack: config =&gt; { ... // 就这一行，让你爽到飞 config.plugin('CompressionPlugin').use(CompressionPlugin, []) }} 然后你就可以通过执行，查看/dist/文件夹下的变化了。 1vue-cli-service build 如果你需要比较详细的配置gzip打包，请移步https://www.npmjs.com/package/compression-webpack-plugin配置里中有一个deleteOriginalAssets属性，意思是删除源文件，一般为false即可，同时保留源文件和压缩后的.gz后缀文件。当然这不是本篇文章的重点。重点是什么？当然是坑了！ nginx如何配置匹配.gz文件？由于现在的浏览器默认支持gzip压缩，你可以在请求头里看到Accept-Encoding: gzip, deflate得以确认。 我司服务器使用nginx做请求转发和实现简单的负载均衡。在网上，不乏有如何在nginx上开启gzip配置的博客或文章。其实蛮简单的，类似一下命令键入打开nginx配置文件： 12cd /usr/local/nginx/conf/vim nginx.conf 再在http模块下添加这么几行配置： 12345678gzip on; // 开启gzipgzip_static on; // 开启gzip静态资源gzip_comp_level 5; // 1-10，数值越大，压缩越狠，但越占用CPU时间，到达6左右，压缩已经不明显了gzip_http_version 1.1 // 1.0或1.1，nginx默认HTTP 1.1gzip_vary on; // 启用应答头\"Vary: Accept-Encoding\"gzip_types text/plain text/css text/javascript application/javascript application/xml application/x-httpd-php application/vnd.ms.fontobject image/jpeg image/png image/gif image/svg+xml font/ttf font/opentype font/x-woff // 压缩类型...// 其他具体配置可自行搜索，此处就不列举了 gzip和gzip_static的区别 gzip：实时压缩，Response Headers 中 的ETag属性存在类似 W/“***”的内容。 gzip_static：优先级高于gzip，会去在目录下优先找带.gz后缀的文件，没有再获取源文件，开启了gzip_static，无须在服务器打包，节约了服务器cpu的使用。 由于项目是在前端构建打包的时候启用了gzip，因为dist内已经有.gz后缀文件，gzip_types设置其实没啥作用（因为有了静态资源，不需要服务器实时压缩）。 坑点一问题命令行中报错，内容如下显示： 1nginx:[emerg] unknown directive \"gzip_static\" in /usr/local/nginx/conf/nginx.conf:35 意思是“gzip_static”指令未知，无法被识别。 解决方式由于安装nginx时缺少了相应配置，需要添加with-http_gzip_static_module配置，在此之前需要先执行以下命令： 1234// 打开nginx脚本目录cd /usr/local/nginx/sbin/// 查看nginx的版本和既有的配置nginx -V 再在nginx安装目录下，重新编译和安装nginx，具体方式如下： 1234567// 打开nginx安装目录cd /nginx-1.9.9/// 添加相应配置（除gzip_static配置外，其他配置均为通过nginx -V查看显示的之前既有配置）./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module// 编译makemake install 需键入nginx -V获取之前的configure，在之前的configure后面添加gzip_static模块 然后等待进程执行完，重新启动nginx即可。 坑点二问题通过以上的方式，nginx已经支持了gzip_static模块，以便nginx优先匹配.gz后缀文件返回。执行以下命令重新nginx： 12cd /usr/local/nginx/sbin/nginx -s reload 好吧，正常情况下，是这样的。 但是… 如果你打开浏览器F12，刷新页面查看资源请求，发现静态资源的Response Headers属性中却没有Content-Encoding: gzip。喔豁…显然配置没有生效啊！ 解决方式我们现在的问题发生在重启了nginx，新添加的模块却没有生效，浏览器还是获取的源文件。此时，我就开始百度了，百度大法好啊，各种回答都出来了。 回答一nginx没有生效，可能是你的配置有误，语法不合法？检查一下： 123cd /usr/local/nginx/sbin/// 添加-t执行检查nginx -t -C /usr/local/nginx/conf/nginx.conf 结果命令行出现以下信息： 12nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 显示语法ok了，测试也通过了，说明正常启动了吧？打开浏览器，又查看了一遍资源加载…… 回答二第一种试过了，哭了。那么nginx重启没生效，会不会是重启没成功啊？软的不行，来硬的呗。键入： 123456// 查看nginx进程，获取到nginx主进程pid为20468ps -ef|grep nginx// 强制删除kill -9 20468// 再次执行确保进程被删除ps -ef|grep nginx 此时，进程中如果没有nginx，kill命令生效了。此时，我重新在命令行中进入nginx命令行目录，运行nginx -s reload，意想不到的问题出来了。 1nginx: [emerg] bind() to [::]:80 failed (98: Address already in use) 我又重新试了kill命令又报错： 1nginx: [alert] kill(20468, 1) failed (3: No such process) 杀掉了主进程，却没有启动成功！吓得我一个激灵看了一下页面，咦？正常情况下，刷新页面，页面会由于nginx进程被kill导致页面无法访问。但是，页面依然能正常打开，俺不信邪，又试了好几个页面，果不其然都行。（不知道是该开心，还是该难过？）nginx进程都没了，为啥还能访问页面？我又经过多方查探，发现有回答说是可能因为程序占用了端口导致kill不掉。在命令行键入以下命令： 123456// 根据端口号将进程列举出来netstat -ntlp// 或者：指定80端口// netstat -ntlp | grep 80// 或者：查看那些程序使用tcp的80端口// fuser -n tcp 80 查看进程列表中是否nginx的占用？ 果不其然，的确有这个进程，再次通过kill命令删除PID进程号，再次执行之前命令，发现列表中nginx进程不复存在了。点此查看彻底删除nginx进程 此时，我们刷新浏览器页面，地址访问不了了，确定nginx已经被彻底删除，此时执行nginx重启命令，测试gzip_static测试是否成功应用。不出意外，nginx应用gzip应该是成功了。此时，你应该能成功看到Request Headers中的Content-Encoding: gzip了，明显能感到页面加载的速度变快了。如果你经过最开始的安装gzip_static后没有出现后续问题，那么恭喜你没有栽坑里[狗头]。如果栽了跟头，希望这篇文章也能帮助到你~ 这次记录就到这了，希望对你能有帮助~Skr","link":"/2021/01/21/gzip_pit/"},{"title":"基于链表的前进撤销实现思路","text":"基于链表的考虑在工作中，处理一组结构类似的数据，往往会采用数组的方式。数组和链表其实都可以作为存储类型类似的数组的选择。为什么要选择链表呢？ 数组 优点：数据连续存放在内存中，通过下标获取访问方便，查询效率较高。 缺点：由于是顺序存储，添加或删除元素，需要操作移动其他元素，效率较低，可能会导致内存浪费。 链表 优点：通过指针的移动可以快速添加或删除元素，效率较高。 缺点：查找会根据指针从头遍历，无法通过下标快速定位，查询效率较低。 二者的关系犹如矛与盾，你唯一的缺点就是没有我…… 前进与撤销需要多次对数据进行添加和删除，因此在实践中，我选择了链表作为存储数据的结构。当然，如果是固定存储长度的实现，比如：只存储10次操作，多于的操作废弃，这种情况下，数组长度不至于过大，也是可以通过数组实现此类工的。 链表选择链表分为单向链表和双向链表，由于前进后撤是需要前后对象的查找，因此选择双向链表。在查找上，双向链表可通过二分法的方式，头尾节点同时查找提高查询效率。 实现思路双向链表的节点只有数据、指向前一个节点的指针和指向后一个节点的指针，在这里我声明Node作为链表的单个节点，Stack记录链表对象的状态。 12345678910111213141516function Node(ele) { this.element = ele; // 存储的数据 this.prev = null; // 前驱指针：指向前一个Node this.next = null; // 后继指针：指向后一个Node}class Stack() { constructor(maxLen) { this.maxLen = maxLen || 10; // 链表最大长度，如不加长度限制则可以不写 this.length = 0; // 当前链表长度 this.head = null; // 头结点指针 this.tail = null; // 尾节点指针 this.finger = 0; // 指针 } ...} 前进撤销的链表操作 链表的增加、删除和清空操作，网上已经有大量代码讲述，代码类似，在此不会贴出全部代码，仅提供思路。 增加增加分为push（追加）和insert（插入） 1const node = new Node(element); // 被插入链表的节点 push：将现有链表的tail尾指针指向node，同时前一个节点的next指针指向node。如果链表长度为0，说明没有节点被插入，直接将头结点和尾节点均指向node。 1234567891011121314151617181920212223242526272829303132333435class Stack(maxLen) { ... /** * @param element 存储的数据 */ push(element) { // 被插入链表的节点 const node = new Node(element); let current; if (this.length === 0) { this.head = node; this.tail = node; } else { current = this.head // 循环，直至获取到当前链表的最后一个节点 while(current.next) { current = current.next } // 由于是双向链表，node的前置指针需要指向current，current的后继指针需要指向node current.next = node node.prev = current // node自然是tail尾节点 this.tail = node } // 链表长度累加 this.length++ // 如果声明了maxLen，当length超出了maxLen，需要从链表头部开始截取第一个节点 // if (this.length - 1 === this.maxLen) { // this.removeNode(0); // } // 指针变动 this.finger = this.length - 1; } ...} insert：插入需要指定元素被插入的下标，分为头部插入，中间插入和尾部插入三种情况，不管是哪种插入，在前进撤销操作中，被插入的node都将作为tail节点，并删除下标对应节点后续的其他节点。 头部插入：前进撤销的头部插入，即将当前node同时指向头结点和尾节点，并将原head节点的next置空。 中间插入：遍历获取到插入节点的current，将node的prev指向到current，将current的next指向node，将node的next置空。 尾部插入：node节点的prev指向到原tail节点（若超出maxLen，则删除链表的第一个节点）。 以下是部分代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Stack(maxLen) { ... /** * @param index 待插入的下标 * @param element 存储的数据 */ insert(index, element) { // 防止越界 if (position &lt; 0 || position &gt;= this.length) { throw new SyntaxError('插入元素下标越界') } // 被插入链表的节点 const node = new Node(element); switch(index) { case 0: // 头部插入 node.next = null; this.head = node; this.length = 1; break; case this.length: // 尾部插入 var tail = this.tail; tail.next = node; node.prev = tail; // 累加长度 this.length++; // 超出截取 // if (this.length - 1 === this.maxLen) { // this.removeNode(0); // } break; default: // 中间插入 var idx = 0; var previous; var current = this.head; while (idx &lt; index) { idx++; previous = current; current = current.next; } // 添加节点之间的关联 previous.next = node; current.prev = node; node.prev = previous; this.length = idx; break; } // 不管是什么操作，tail节点都是node this.tail = node; // 指针变动 this.finger = this.length -1; } ...} 删除删除同修改一样，与修改不同的是，将tail置为null，如果删除下标为0，则清空链表。 清空链表的清空操作很简单，只需要重置头尾节点，指针清零即可，javascript内存机制中垃圾回收机制会自动回收不再使用的数据内存，这使得我们不需要手动释放内存。 1234567891011class Stack(maxLen) { ... // 清空 empty() { this.head = null; // 重置头指针 this.tail = null; // 重置尾指针 this.length = 0; // 重置长度 this.finger = 0; // 重置指针变动 } ...} 前进撤销的基本思路是点击按钮切换Stack的finger指针下标，根据下标获取对应的Node节点，将节点中的数据返回到页面上重新渲染。 至此，基于链表的前进撤销基本操作完成了，undo（撤销）和redo（前进）移动finger指针，通过指针指向下标获取对应链表存储的数据的逻辑，是不是很容易实现呢？^ _ ^","link":"/2019/08/16/redo-undo/"}],"tags":[{"name":"其他","slug":"其他","link":"/tags/其他/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"那些年我走过的坑","slug":"那些年我走过的坑","link":"/categories/那些年我走过的坑/"},{"name":"前端大爆炸","slug":"前端大爆炸","link":"/categories/前端大爆炸/"}]}